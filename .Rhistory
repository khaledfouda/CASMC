m = 10
n = 15
J = 5
y <- rbinom(m*n, 1, .2)
y
y <- rbinom(m*n, 1, .2) %>% as("incomplete")
library(tidyverse)
install.packages("tidyverse")
library(dplyr)
library(magrittr)
y
y <- rbinom(m*n, 1, .2) %>% as("incomplete")
y <- rbinom(m*n, 1, .2) %>% as("Incomplete")
packages <-
c(
"tidyverse",
"kableExtra",
"tidyverse",
"doParallel",
"foreach",
"hexbin",
"patchwork",
"ggplot2",
"softImpute",
"irlba", # propack
"MASS", # ginv (alternative to solve())
"svd", # another propack. i forgot which one i ended up using :)
"corpcor", # fast.svd
"magrittr",
"RSpectra",
"Matrix",
"knitr",
"roxygen2" # to create help pages
)
# unload the packages if they're loaded.
for (pkg in packages) {
name = paste0("package:",pkg)
if (name %in% search()) {
suppressMessages(suppressWarnings(detach(
name,
unload = TRUE,
character.only = TRUE,
force = F
)))
}
}
# load the packages
for (pkg in packages) {
print(paste("Package", pkg, "loaded."))
suppressMessages(suppressWarnings(library(
pkg, character.only = TRUE, quietly = TRUE
)))
}
install.packages(packages)
install.packages(packages)
# unload the packages if they're loaded.
for (pkg in packages) {
name = paste0("package:",pkg)
if (name %in% search()) {
suppressMessages(suppressWarnings(detach(
name,
unload = TRUE,
character.only = TRUE,
force = F
)))
}
}
# load the packages
for (pkg in packages) {
print(paste("Package", pkg, "loaded."))
suppressMessages(suppressWarnings(library(
pkg, character.only = TRUE, quietly = TRUE
)))
}
y <- rbinom(m*n, 1, .2) %>% as("incomplete")
y <- rbinom(m*n, 1, .2) %>% as("Incomplete")
y <- rbinom(m*n, 1, .2) %>% as.matrix(m,n) %>% as("Incomplete")
y
y <- rbinom(m*n, 1, .2) %>% as.matrix(m,n) %>% as("incomplete")
y <- rbinom(m*n, 1, .2) %>% as.matrix(m,n)
y[y==0] <- NA
y %<>% as("Incomplete")
U <- rnom(m*J) %>% as.matrix(m,J)
U <- rnom(m*J) %>% matrix(m,J)
U <- rnorm(m*J) %>% as.matrix(m,J)
V <- rnorm(n*J) %>% as.matrix(n,J)
source("~/OneDrive/Research/Summer25/CASMC/code_files/delete.R")
VDsq = t(Dsq * t(V))
B = t(U) %*% y + t(VDsq)
dim(y)
U <- rnorm(m*J) %>% matrix(m,J)
V <- rnorm(n*J) %>% matrix(n,J)
y <- rbinom(m*n, 1, .2) %>% matrix(m,n)
y[y==0] <- NA
y %<>% as("Incomplete")
VDsq = t(Dsq * t(V))
B = t(U) %*% y + t(VDsq)
dim(y)
all(
crossprod(y, U) ==
t(U) %*% y
)
crossprod(y, U)
t(U) %*% y
all(
crossprod(y, U) ==
t(U) %*% y
)
all(
t(crossprod(y, U) + VDsq) ==
B
)
B = as.matrix(t((B) * (Dsq / (Dsq + lambda.M))))
lambda.M = 1.2
B = as.matrix(t((B) * (Dsq / (Dsq + lambda.M))))
B2 = t(crossprod(y, U) + VDsq)
B2 = sweep(B2, 2L, (Dsq / (Dsq + lambda.M)), `*`)
all(B==B2)
all(B==t(B2))
B
B2
t(B2)
B
Dstar = (Dsq / (Dsq + lambda.M))
B2 = (crossprod(y, U) + VDsq)
B2 = sweep(B2, 2L, (Dsq / (Dsq + lambda.M)), `*`)
all(B==t(B2))
all(B==(B2))
B = as.matrix(t((B) * Dstar))
B = t(U) %*% y + t(VDsq)
B2 = (crossprod(y, U) + VDsq)
B2 = sweep(B2, 2L, (Dsq / (Dsq + lambda.M)), `*`)
all(B==(B2))
all(B==t(B2))
B = t(U) %*% y + t(VDsq)
B = as.matrix(t((B) * Dstar))
B2 = (crossprod(y, U) + VDsq)
B2 = sweep(B2, 2L, (Dsq / (Dsq + lambda.M)), `*`)
all(B==(B2))
library(microbenchmark)
library(microbenchmark)
res1  <- microbenchmark(
old_D = {Dsq / (Dsq + lambda.M)},
new_D = {(1 + lambda.M * Dsq^(-2))^(-1)}
)
res1  <- microbenchmark(
old_D = {Dsq / (Dsq + lambda.M)},
new_D = {(1 + lambda.M * Dsq^(-2))^(-1)},
times = 100L, units = "ms"
)
print(res1)
plot(res1)
res1  <- microbenchmark(
old_D = {Dsq / (Dsq + lambda.M)},
new_D = {1/(1 + lambda.M * Dsq^(-2))},
times = 100L, units = "ms"
)
print(res1)
res1  <- microbenchmark(
old_D = {Dsq / (Dsq + lambda.M)},
new_D = {1/(1 + lambda.M * (1/Dsq) )},
times = 100L, units = "ms"
)
print(res1)
res1  <- microbenchmark(
old_D = {Dsq / (Dsq + lambda.M)},
new_D = {1/(1 + lambda.M * (1/Dsq) )},
times = 1000L, units = "ms"
)
print(res1)
B2 = sweep(B2, 2L, (Dsq / (Dsq + lambda.M)), `*`)
res2  <- microbenchmark(
old_D = {
B = t(U) %*% y + t(VDsq)
B = as.matrix(t((B) * Dstar))
},
new_D = {
B2 = (crossprod(y, U) + VDsq)
B2 = sweep(B2, 2L, (Dsq / (Dsq + lambda.M)), `*`)
},
times = 1000L, units = "ms"
)
print(res2)
res2  <- microbenchmark(
old_D = {
B = t(U) %*% y + t(VDsq)
B = as.matrix(t((B) * Dstar))
},
new_D = {
B2 = (crossprod(y, U) + VDsq)
B2 = sweep(B2, 2L, (Dsq / (Dsq + lambda.M)), `*`)
},
times = 1000L, units = "sec"
)
print(res2)
res2  <- microbenchmark(
old_D = {
B = t(U) %*% y + t(VDsq)
B = as.matrix(t((B) * Dstar))
},
new_D = {
B2 = (crossprod(y, U) + VDsq)
B2 = sweep(B2, 2L, (Dsq / (Dsq + lambda.M)), `*`)
},
times = 1000L#, units = "sec"
)
print(res2)
plot(res2)
res2  <- microbenchmark(
old_D = {
B = t(U) %*% y + t(VDsq)
B = as.matrix(t((B) * Dstar))
},
new_D = {
B2 = (crossprod(y, U) + VDsq)
B2 = sweep(B2, 2L, Dstar, `*`)
},
times = 1000L#, units = "sec"
)
print(res2)
B = t(U) %*% y + t(VDsq)
res2  <- microbenchmark(
old_D = {
B = t(U) %*% y + t(VDsq)
#B = as.matrix(t((B) * Dstar))
},
new_D = {
B2 = (crossprod(y, U) + VDsq)
#B2 = sweep(B2, 2L, Dstar, `*`)
},
times = 1000L#, units = "sec"
)
print(res2)
res2  <- microbenchmark(
old_D = {
#B = t(U) %*% y + t(VDsq)
B11 = as.matrix(t((B) * Dstar))
},
new_D = {
#B2 = (crossprod(y, U) + VDsq)
B222 = sweep(B2, 2L, Dstar, `*`)
},
times = 1000L#, units = "sec"
)
print(res2)
B2 = t(B2 * Dstar)
B2 = (t(B2) * Dstar)
B2
B2 = as.matrix(t(B2) * Dstar)
B2 = (crossprod(y, U) + VDsq)
B2 = as.matrix(t(B2) * Dstar)
all(B==(B2))
B = t(U) %*% y + t(VDsq)
B = as.matrix(t((B) * Dstar))
all(B==(B2))
B2 = (crossprod(y, U) + VDsq)
B2 = as.matrix((B2) * Dstar)
B2 = as.matrix(Dstar * B2)
B2 = (crossprod(y, U) + VDsq)
B2 = as.matrix(Dstar * B2)
dim(B2)
B = t(U) %*% y + t(VDsq)
dim(B)
B2 * Dstar
length(Dstar)
B2 * t(Dstar)
B %*% diag(Dstar)
B2%*% diag(Dstar)
B = t(U) %*% y + t(VDsq)
B2 = (crossprod(y, U) + VDsq)
res2  <- microbenchmark(
old_D = {
#B = t(U) %*% y + t(VDsq)
B11 = as.matrix(t((B) * Dstar))
},
new_D = {
#B2 = (crossprod(y, U) + VDsq)
B22 = as.matrix(B2 %*% diag(Dstar))
# B22 = sweep(B2, 2L, Dstar, `*`)
},
times = 1000L#, units = "sec"
)
print(res2)
print(res2)
res2  <- microbenchmark(
old_D = {
#B = t(U) %*% y + t(VDsq)
B11 = as.matrix(t((B) * Dstar))
},
new_D = {
#B2 = (crossprod(y, U) + VDsq)
B22 = as.matrix(B2 %*% diag(Dstar))
# B22 = sweep(B2, 2L, Dstar, `*`)
},
times = 1000L#, units = "sec"
)
print(res2)
B2
B2[] <- B2
B2
res2  <- microbenchmark(
old_D = {
#B = t(U) %*% y + t(VDsq)
B22 = as.matrix(B2 %*% Diagonal(x=Dstar))
#B11 = as.matrix(t((B) * Dstar))
},
new_D = {
#B2 = (crossprod(y, U) + VDsq)
B22 = as.matrix(B2 %*% diag(Dstar))
# B22 = sweep(B2, 2L, Dstar, `*`)
},
times = 1000L#, units = "sec"
)
print(res2)
res2  <- microbenchmark(
old_D = {
#B = t(U) %*% y + t(VDsq)
B22 = (B2 %*% diag(Dstar))
#B11 = as.matrix(t((B) * Dstar))
},
new_D = {
#B2 = (crossprod(y, U) + VDsq)
B22 = as.matrix(B2 %*% diag(Dstar))
# B22 = sweep(B2, 2L, Dstar, `*`)
},
times = 1000L#, units = "sec"
)
print(res2)
#B = t(U) %*% y + t(VDsq)
B22 = (B2 %*% diag(Dstar)) %>% as.matrix()
res2  <- microbenchmark(
old_D = {
#B = t(U) %*% y + t(VDsq)
B22 = (B2 %*% diag(Dstar)) %>% as.matrix()
#B11 = as.matrix(t((B) * Dstar))
},
new_D = {
#B2 = (crossprod(y, U) + VDsq)
B22 = as.matrix(B2 %*% diag(Dstar))
# B22 = sweep(B2, 2L, Dstar, `*`)
},
times = 1000L#, units = "sec"
)
print(res2)
print(res2)
print(res2)
res2  <- microbenchmark(
old_D = {
#B = t(U) %*% y + t(VDsq)
B22 = (B2 %*% diag(Dstar))
B22 = as.matrix(B22)
#B11 = as.matrix(t((B) * Dstar))
},
new_D = {
#B2 = (crossprod(y, U) + VDsq)
B22 = as.matrix(B2 %*% diag(Dstar))
# B22 = sweep(B2, 2L, Dstar, `*`)
},
times = 1000L#, units = "sec"
)
print(res2)
print(res2)
svd(B22)
#B = t(U) %*% y + t(VDsq)
B22 = (B2 %*% diag(Dstar))
svd(B22)
fast.svd(B22)
B2 = (crossprod(y, U) + VDsq)
#B = t(U) %*% y + t(VDsq)
B22 = (B2 %*% diag(Dstar))
fast.svd(B22)
### fast.svd.R  (2006-04-24)
###
###    Efficient Computation of the Singular Value Decomposition
###
### Copyright 2003-06 Korbinian Strimmer
###
###
### This file is part of the `corpcor' library for R and related languages.
### It is made available under the terms of the GNU General Public
### License, version 3, or at your option, any later version,
### incorporated herein by reference.
###
### This program is distributed in the hope that it will be
### useful, but WITHOUT ANY WARRANTY; without even the implied
### warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
### PURPOSE.  See the GNU General Public License for more
### details.
###
### You should have received a copy of the GNU General Public
### License along with this program; if not, write to the Free
### Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
### MA 02111-1307, USA
# private functions
# svd that retains only positive singular values
positive.svd = function(m,  trim = TRUE, tol = NULL)
{
s = svd(m)
if (!trim)
return(s)
if (is.null(tol))
tol = max(dim(m)) * max(s$d) * .Machine$double.eps
Positive = s$d > tol
return(list(
d = s$d[Positive],
u = s$u[, Positive, drop = FALSE],
v = s$v[, Positive, drop = FALSE]
))
}
# fast computation of svd(m) if n << p
# (n are the rows, p are columns)
utils$svd_small_nr <-
nsmall.svd <-
function(m, trim = FALSE, tol = NULL, n = nrow(m))
{
B = as.matrix(m %*% t(m), n, n)     # nxn matrix
s = svd(B, nv = 0)    # of which svd is easy..
if (!trim) {
d = pmax(sqrt(s$d), .Machine$double.eps)
u = as.matrix(s$u, n)
return(list(
d = d,
u = u,
v = crossprod(m, u) %*% diag(1 / d, length(d))
))
}
# determine rank of B  (= rank of m)
if (is.null(tol))
tol = dim(B)[1] * max(s$d) * .Machine$double.eps
Positive = s$d > tol
# positive singular values of m
d = sqrt(s$d[Positive])
# corresponding orthogonal basis vectors
u = s$u[, Positive, drop = FALSE]
v = crossprod(m, u) %*% diag(1 / d, nrow = length(d))
return(list(d = d, u = u, v = v))
}
utils <- new.env()
path_to_proj = "/mnt/campus/math/research/kfouda/main/HEC/Youssef/HEC_MAO_COOP/"
# setwed(path_to_proj)
path_to_code = paste0(path_to_proj, "functions/")
path_to_data = paste0(path_to_proj, "saved_data/")
file_list <-
list.files(
path = path_to_code,
pattern = "\\.R$",
full.names = TRUE,
recursive = T
)
file_list
pwd
setwd("~/OneDrive/Research/Summer25/CASMC/functions/utils")
path_to_proj = "~/OneDrive/Research/Summer25/CASMC/"
# setwed(path_to_proj)
path_to_code = paste0(path_to_proj, "functions/")
path_to_data = paste0(path_to_proj, "saved_data/")
file_list <-
list.files(
path = path_to_code,
pattern = "\\.R$",
full.names = TRUE,
recursive = T
)
file_list <- file_list[!grepl("main\\.R$", file_list)]
file_list <- file_list[!grepl("main[0-9]*\\.R$", file_list)]
file_list <- file_list[!grepl("/old/", file_list)]
file_list <- file_list[!grepl("/old.*/", file_list)]
. = lapply(file_list, source)
B2 = (crossprod(y, U) + VDsq)
B2 = as.matrix(B2 %*% diag(Dstar))
B = t(U) %*% y + t(VDsq)
B = as.matrix(t((B) * Dstar))
all(B==(B2))
res2  <- microbenchmark(
old_D = {
#B = t(U) %*% y + t(VDsq)
# B22 = (B2 %*% diag(Dstar))
# B22 = as.matrix(B22)
A = (y %*% V) + sweep(U, 2L, Dsq, `*`)
#
#B11 = as.matrix(t((B) * Dstar))
},
new_D = {
#B2 = (crossprod(y, U) + VDsq)
A = (y %*% V) + t(Dsq * t(U))
#B22 = as.matrix(B2 %*% diag(Dstar))
# B22 = sweep(B2, 2L, Dstar, `*`)
},
times = 1000L#, units = "sec"
)
print(res2)
DSq
Dsq
t(Dsq * t(U))
crossprod(Dsq, U)
crossprod(U, Dsq)
crossprod(U, diag(Dsq))
crossprod(diag(Dsq), U)
diag(Dsq)
U
